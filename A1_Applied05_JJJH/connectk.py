"""
FIT1045: Sem 1 2023 Assignment 1 (Solution Copy)
"""
import random
import os

# Player symbols to be used in the board in array for ease of changing and scaling
n_players = 2
rows = 6
columns = 7
connected_tokens = 4

player_symbols = ["X", "O"]

def clear_screen():
	"""
	Clears the terminal for Windows and Linux/MacOS.

	:return: None
	"""
	os.system('cls' if os.name == 'nt' else 'clear')


def validate_input(prompt, valid_inputs):
	"""
	Repeatedly ask user for input until they enter an input
	within a set valid of options.

	:param prompt: The prompt to display to the user, string.
	:param valid_inputs: The range of values to accept, list
	:return: The user's input, int.
	"""
	selected = 0

	# Loops until valid input is received
	while selected != 1:
		choice = input(prompt)

		# Checks if input is valid then returns it
		if(choice in valid_inputs): 
			selected = 1
			return choice
		else:
			print("Invalid input, please try again.")


def game_settings():
	"""
	Prompts the user for the game settings and store them as runtime variables.
	Default game settings:
	- Number of players: 2
	- Player symbols: X and O (autogenerated based on number of players, max 26)
	- Number of rows: 6
	- Number of columns: 7
	- Number of connected tokens to win: 4

	:return: 1 if game settings are valid, 0 if invalid, int.
	"""
	global n_players, rows, columns, connected_tokens, player_symbols
	row_selected , column_selected = 0, 0
	confirmed_settings = 0

	# Repeatedly prompts the user for the game settings until a confirmation is received
	while not confirmed_settings:
		# Prompts the user for the number of players
		n_players = int(validate_input("Enter the number of players(2-26): ", [str(i) for i in range(2, 27)]))

		# Prompts the user for the number of rows
		while not row_selected:
			rows = int(input("Enter the number of rows(min 3): "))

			if rows < 3:
				print("The number of rows must be at least 3.")
			else:
				row_selected = 1

		# Prompts the user for the number of columns
		while not column_selected:
			columns = int(input("Enter the number of columns(min {}): ".format(n_players)))

			if columns < n_players:
				print("The number of columns must be at least {}.".format(n_players))
			else:
				column_selected = 1

		# Repeatedly prompts for the user until a valid input is received for the number of connected tokens required to win
		if rows < 4 or columns < 4:
			print("Auto set connected tokens to win to 3. (Any value less than 3 will make the game always a win for the first player.)")
			connected_tokens = 3
		else:
			connected_tokens = int(validate_input("Enter the number of connected tokens to win({}-{}): ".format(3, min(rows, columns)), [str(i) for i in range(3, min(rows, columns) + 1)]))

		# Generates player symbols based on number of players based on ASCII values if it exceeds 2
		if n_players > 2:
			player_symbols = [chr(i + 65) for i in range(n_players)]
		else:
			player_symbols = ["X", "O"]

		# Prompts the user to confirm game settings with print-out of the game settings
		clear_screen()
		print("Game Settings Preview:")
		print("- Number of players: {}".format(n_players))
		print("- Number of connected tokens to win: {}".format(connected_tokens))
		print("- Board dimensions: {}x{}".format(rows, columns))
		print()

		confirmation = validate_input("Do you agree with the game settings?(Y\u0332es/N\u0332o): ", ["yes", "y", "no", "n", "Yes", "YES", "Y", "No", "NO", "N"])

		if(confirmation == "yes" or confirmation == "y" or confirmation == "Yes" or confirmation == "YES" or confirmation == "Y"):
			confirmed_settings = 1
			clear_screen()
			return 1
		elif(confirmation == "no" or confirmation == "n" or confirmation == "No" or confirmation == "NO" or confirmation == "N"):
			row_selected , column_selected = 0, 0
			confirmed_settings = 0


def print_rules():
	"""
	Prints the rules of the game.

	:param player: The number of players, int, default 2.
	:param rows: The number of rows in the board, int, default 6.
	:param columns: The number of columns in the board, int, default 7.
	:param tokens: The number of tokens required to win, int, default 4.
	:return: None
	"""
	print("================= Rules =================")
	print("Connect K is a custom game where the")
	print("number of players, CPU players, board")
	print("size and number of tokens required to")
	print("win can be customized. The game objective")
	print("is to get k number of your pieces")
	print("in a row either horizontally, vertically")
	print("or diagonally. The game is played on a")
	print("mxn grid. The first player to get k")
	print("pieces consecutively wins the game. If the")
	print("grid is filled and no player has won,")
	print("the game is a draw.")
	print("=========================================")


def create_board(rows, columns):
	"""
	Returns a 2D list of rows and 7 columns to represent
	the game board. Default cell value is 0.

	:param rows: The number of rows in the board, int, default 6. 
	:param columns: The number of columns in the board, int, default 7.
	:return: A 2D list of row x column dimensions .
	"""

	# Creates a 2D list of 0s with 6 rows and 7 columns
	board = [[0 for i in range(columns)] for j in range(rows)]

	# Returns the board to the caller
	return board


def print_board(board):
	"""
	Prints the game board to the console.

	:param board: The game board, 2D list of m x n dimensions.
	:return: None
	"""
	# Prints the board header consisting game name and player symbol
	print("=" + " Connect4 ".center(len(board[0]) * 4, "="))

	cycle = 1
	for i in range(n_players):
		if(cycle == 1):
			print("{:<{width}}".format(
				"Player {}: {}".format(i + 1, player_symbols[i]), 
				width = len(board[0]) * 2 + 1),
			end = "")
			cycle += 1
		elif(cycle == 2):
			print("{:>{width}}\n".format(
				"Player {}: {}".format(i + 1, player_symbols[i]), 
				width = len(board[0]) * 2), 
			end = "")
			cycle -= 1
	print()


	# Prints the play area of the board and its contents:
	# 1. Prints the column numbers
	for i in range(len(board[0])):
		print("  {}".format(i + 1), end = "")
		if(i < (len(board[0]) - 1)): print(" ", end = "")
	print()

	# 2. Prints the boxes of the board
	for i in range(len(board[0])):
		print(" ---", end = "")
	print()

	for i in range(len(board)):
		print("|", end = "")
		for j in range(len(board[i])):
			# Prints the contents of the box given the value of the cell 
			# (0 = empty, non-zero = corresponding player symbol)
			print(" {} ".format(" " if board[i][j] == 0 else player_symbols[board[i][j] - 1]), end = "|")
		print()
		for i in range(len(board[0])):
			print(" ---", end = "")
		print()
	# ===============================

	# 3. Prints the bottom section of the board
	for i in range(len(board[0]) * 4 + 1):
		print("=", end = "")
	print()


def drop_piece(board, player, column):
	"""
	Drops a piece into the game board in the given column.
	Please note that this function expects the column index
	to start at 1.

	:param board: The game board, 2D list of row x column dimensions.
	:param player: The player who is dropping the piece, int.
	:param column: The index of column to drop the piece into, int.
	:return: Row dropped into if piece was successfully dropped, False if not.
	"""
	for r in range(len(board) - 1, -1, -1):
		if(board[r][column - 1] == 0):
			board[r][column - 1] = player
			return True
		elif(r == 0):
			return False


def execute_player_turn(board, player):
	"""
	Prompts user for a legal move given the current game board
	and executes the move.

	:param board: The game board, 2D list of row x column dimensions.
	:param player: The player who is dropping the piece, int.
	:return: Row and Column that the piece was dropped into(int), if successful.
	"""
	while True:
		# Prompts player for a column to drop their piece into
		play = validate_input(
			"Player {}, please enter the column you would like to drop your piece into: ".format(player), 
			[str(i) for i in range(1, len(board[0]) + 1)]
		)

		if drop_piece(board, player, int(play)):
			return int(play)
		else:
			print("That column is full, please try again.")


def end_of_game(board):
	"""
	Checks if the game has ended with a winner
	or a draw.

	:param board: The game board, 2D list of 6 rows x 7 columns.
	:return: 0 if game is not over, 1 if player 1 wins, 2 if player 2 wins, 3 if draw.
	"""
	rows = len(board)
	columns = len(board[0])

	connected = 0
	# Starts the board check from the bottom row up
	for i in range(rows - 1, -1, -1):
		# Alternates checking between player 1 and player 2 
		for j in range(1, n_players + 1):
			# Loops through each column for each row
			for k in range(columns):
				# Checks for horizontal win
				if(k <= (columns - 4)):
					if(board[i][k] == j and board[i][k + 1] == j and board[i][k + 2] == j and board[i][k + 3] == j):
						connected = 1
						return j
				# Ensures that the rows iterated are the bottom 3 rows since the checking method is
                # to check 4 consecutive cells at once
				if(i >= 3):
					# Checks for vertical win
					if(board[i][k] == j and board[i - 1][k] == j and board[i - 2][k] == j and board[i - 3][k] == j):
						connected = 1
						return j
					# Checks for bottom left to top right diagonal win
					if(k <= (columns - 4) and board[i][k] == j and board[i - 1][k + 1] == j and board[i - 2][k + 2] == j and board[i - 3][k + 3] == j):
						connected = 1
						return j
					# Checks for top left to bottom right diagonal win
					if(k >= 3 and board[i][k] == j and board[i - 1][k - 1] == j and board[i - 2][k - 2] == j and board[i - 3][k - 3] == j):
						connected = 1
						return j

	# Checks the state of the game if there are no wins
	if not connected:
		for row in range(len(board)):
			row = board[row]
			if 0 in row:    # If there are still empty cells, game is still ongoing
				return 0
			else:
				return 3    # No more empty cells, the game is a draw


def local_k_player_game():
	"""
	Runs a local n_player game of Connect k.

	:return: None
	"""
	board = create_board(rows, columns)
	game_end = 0

	# Stores last played player and column
	last_played = [0, 0]

	# Game loop
	while not game_end:
		# Alternates from Player 1 to n_players
		for i in range(1, n_players + 1):
			clear_screen()
			print_board(board)
			# Prints last played piece and corresponding player
			if(last_played[0] != 0):
				print("Player {} dropped a piece into column {}".format(last_played[0], last_played[1]))

			# Stores last played piece and corresponding player and execute player turn
			last_played[0] = i
			last_played[1] = execute_player_turn(board, i)
			
			# Checks if the game has ended
			game_state = end_of_game(board)

			# If game has ended, prints the board and the winner
			if(game_state):
				game_end = 1
				clear_screen()
				print_board(board)
				print("Player {} wins!".format(i) if game_state != 3 else "Draw!")
				break


def main():
	"""
	Defines the main application loop.
    User chooses a type of game to play or to exit.

	:return: None
	"""
	playing = 1

	while playing:
		clear_screen()
		print("=============== Main Menu ===============")
		print("Welcome to Connect K!")
		print("Please select an option:")
		print("1. View Rules")
		print("2. Play a local game with custom settings")
		print("3. Play a game against the computer with custom settings")
		print("4. Exit")
		print("=========================================")

		choice = validate_input("Please enter your choice: ", ["1", "2", "3", "4"])

		# Processes user input
		if(choice == "1"): # Views rules
			clear_screen()
			print_rules()
			exit = validate_input("Click Enter to return to the Main Menu. ", [""])
		elif(choice == "2"): # Plays a local 2 player game
			clear_screen()
			game_settings()
			local_k_player_game()
			exit = validate_input("Click Enter to return to the Main Menu. ", [""])
		elif(choice == "3"): # Plays a game against the computer
			clear_screen()
			game_settings()
			print("CPU is always the even-numbered player.")
			cpu_player_choice = int(validate_input(
					"Please select a difficulty level (1 => Easy, 2 => Medium, 3 => Hard): ", 
					["1", "2", "3"]
				)
			)
			game_against_cpu(cpu_player_choice)
			exit = validate_input("Click Enter to return to the Main Menu. ", [""])
		elif(choice == "4"): # Exits
			clear_screen()
			playing = 0


def cpu_player_easy(board, player):
	"""
	Executes a move for the CPU on easy difficulty. This function 
	plays a randomly selected column.

	:param board: The game board, 2D list of m x n dimensions.
	:param player: The player whose turn it is, integer value of 1 to n_players.
	:return: Column that the piece was dropped into, int.
	"""
	# Implement your solution below
	
	# Assigns loop variable 'successful_drop' to False
	successful_drop = False

    # Loops until there is a successful drop
	while successful_drop != True:
		# Attempts to drop a piece into a random column
		random_column = random.randint(1, 7)
                
		# If successful, updates successful_drop to True
        # Terminates loop and returns the random column
		successful_drop = drop_piece(board, player, random_column)
	return random_column
	

def horizontal_win(board):

    # Iterates through each row on the board until the last row
    for row in range(0, len(board)):
        
        # Iterates from the 1st to the 4th column
        for column in range(0, 4):
            player = board[row][column]

            # Checks that the current cell is not empty
            if player != 0:
                # If next three cells in the row have the same value as the current cell, return the Winner's number
                if player == board[row][column + 1] == board[row][column + 2] == board[row][column + 3]:
                    return player

    return 0    # No horizontal win detected
        

def vertical_win(board):

    # Iterates from the 1st to 3rd row
    for row in range (0, 3):

        # Iterates through each column until the last column
        for column in range(0, 7):
            player = board[row][column]

            # Checks that the current cell is not empty
            if player != 0:
                # If next three cells in the column have the same value as the current cell, return the Winner's number
                if player == board[row + 1][column] == board[row + 2][column] == board[row + 3][column]:
                    return player

    return 0 # No vertical win detected
    

def diagonal_win(board):

    # Iterates from the 4th row to the last row
    for row in range(3, len(board)):

        # Iterates from the 1st to the 3rd column
        for column in range(0, 4):
            player = board[row][column]

            # Checks that the current cell is not empty
            if player != 0:
                # Checks for a bottom-left to top-right connection
                if player == board[row-1][column+1] == board[row-2][column+2] == board[row-3][column+3]:
                    return player

    # Iterates from the 1st to 3rd row
    for row in range(0, 3):

        # Iterates from the 1st column to the 4th column
        for column in range(0, 4):
            player = board[row][column]

            # Checks that the current cell is not empty
            if player != 0:
                # Checks for a top-left to bottom-right connection
                if player == board[row+1][column+1] == board[row+2][column+2] == board[row+3][column+3]:
                    return player

    return 0    # No diagonal win detected


def cpu_player_medium(board, player):
	"""
	Executes a move for the CPU on medium difficulty. 
	It first checks for an immediate win and plays that move if possible. 
	If no immediate win is possible, it checks for an immediate win 
	for the opponent and blocks that move. If neither of these are 
	possible, it plays a random move.

	:param board: The game board, 2D list of m x n dimensions.
	:param player: The player whose turn it is, integer value of 1 to n_players.
	:return: Column that the piece was dropped into, int.
	"""

	# Determines Player number
	opponent = 1 if player == 2 else 2

    # Checks for immediate win
	for column in range(7):
		for row in reversed(range(len(board))):
			if board[row][column] == 0:
                # Tries dropping the player's piece to see if it results to a win
				board[row][column] = player
				if horizontal_win(board) == player: 
					return column + 1
				elif vertical_win(board) == player:
					return column + 1
				elif diagonal_win(board) == player:
					return column + 1
				else:
                    # Undos the drop if it doesn't result to an immediate win
					board[row][column] = 0
				break	# Breaks out of the inner loop to move to the next column


    # Checks for opponent's potential immediate win and blocks it
	for column in range(7):
		for row in reversed(range(len(board))):
			if board[row][column] == 0:
                # Tries dropping the opponent's piece to see if it results to a win
				board[row][column] = opponent
				if horizontal_win(board) == opponent:
					# Blocks the win
					board[row][column] = player
					return column + 1
				elif vertical_win(board) == opponent:
					# Blocks the win
					board[row][column] = player
					return column + 1
				elif diagonal_win(board) == opponent:
					# Blocks the win
					board[row][column] = player
					return column + 1
				else:
                    # Undos the drop if there is no potential immediate win for the opponent
					board[row][column] = 0
				break	# Breaks out of the inner loop to move to the next column


    # Random drop if no immediate win or block
	successful_drop = False
	
	while successful_drop != True:
		random_column = random.randint(1, 7)
		successful_drop = drop_piece(board, player, random_column)
		
	return random_column


def cpu_player_hard(board, player):
    """
    Executes a move for the CPU on hard difficulty.
	This function creates a copy of the board to simulate moves.

    It first checks for an immediate win and plays that move if possible. 
    If no immediate win is possible, it checks for an immediate win 
    for the opponent and blocks that move. If neither of these are 
    possible, it plays in the center columns (4, 3 and 5) to get more
    winning combinations. If all the specified cells in the center columns  
    are occupied, it plays a random move.
    
    :param board: The game board, 2D list of m x n dimensions.
    :param player: The player whose turn it is, integer value of 1 to n_players.
    :return: Column that the piece was dropped into, int.
    """

    # Determines Player number
    opponent = 1 if player == 2 else 2

    # Checks for immediate win
    for column in range(7):
        for row in reversed(range(len(board))):
            if board[row][column] == 0:
                # Tries dropping the player's piece to see if it results to a win
                board[row][column] = player
                if horizontal_win(board) == player: 
                    return column + 1
                elif vertical_win(board) == player:
                    return column + 1
                elif diagonal_win(board) == player:
                    return column + 1
                else:
                    # Undos the drop if it doesn't result to an immediate win
                    board[row][column] = 0
                break # Breaks out of the inner loop to move to the next column

    # Checks for opponent's potential immediate win and blocks it
    for column in range(7):
        for row in reversed(range(len(board))):
            if board[row][column] == 0:
                # Tries dropping the opponent's piece to see if it results to a win
                board[row][column] = opponent
                if horizontal_win(board) == opponent:
                    # Blocks the win
                    board[row][column] = player
                    return column + 1
                elif vertical_win(board) == opponent:
                    # Blocks the win
                    board[row][column] = player
                    return column + 1
                elif diagonal_win(board) == opponent:
                    # Blocks the win
                    board[row][column] = player
                    return column + 1
                else:
                    # Undos the drop if there is no immediate win possible for the opponent
                    board[row][column] = 0
                break # Breaks out of the inner loop to move to the next column
                

    # Prioritizes center columns
    if board[5][3] == 0:  
        drop_piece(board, player, 4)
        return 4
    elif board[4][3] == 0:  
        drop_piece(board, player, 4)
        return 4
    elif board[5][4] == 0: 
        drop_piece(board, player, 5)
        return 5
    elif board[4][4] == 0:  
        drop_piece(board, player, 5)
        return 5
    elif board[5][2] == 0: 
        drop_piece(board, player, 3)
        return 3
    elif board[4][2] == 0: 
        drop_piece(board, player, 3)
        return 3
    elif board[3][3] == 0:  
        drop_piece(board, player, 4)
        return 4
    elif board[3][2] == 0: 
        drop_piece(board, player, 3)
        return 3
    elif board[3][4] == 0: 
        drop_piece(board, player, 5)
        return 5
    elif board[2][3] == 0:  
        drop_piece(board, player, 4)
        return 4
    elif board[2][2] == 0: 
        drop_piece(board, player, 3)
        return 3
    elif board[2][4] == 0: 
        drop_piece(board, player, 5)
        return 5
    
    # Random drop if no strategic move is found
    successful_drop = False
    while successful_drop != True:
        random_column = random.randint(1, 7)
        successful_drop = drop_piece(board, player, random_column)
	
    return random_column

    
def cpu_player_selector(difficulty, board, player):
	"""
	Selects the CPU player function based on the difficulty level.

	:param difficulty: The difficulty level of the CPU player.
	:param board: The game board, 2D list of 6x7 dimensions.
	:param player: The player whose turn it is, integer value of 1 or 2.
	:return: The CPU player function.
	"""
	match difficulty:
		case 1:
			return cpu_player_easy(board, player)
		case 2:
			return cpu_player_medium(board, player)
		case 3:
			return cpu_player_hard(board, player)
	
def game_against_cpu(cpu_player: int):
	"""
	Runs a game of Connect K against the computer.

	:param cpu_player: The difficulty level of the CPU player. 1 => Easy, 2 => Medium, 3 => Hard.
	:return: None
	"""
	board = create_board(rows, columns)
	game_end = 0
	game_state = 0

	# Stores last played player and column [local_player, cpu_player]
	local_last_played = [0, 0]
	cpu_last_played = [0, 0]

	# Game loop
	while not game_end:
		# Alternates from Player 1 to n_players
		for i in range(n_players - 1):
			# Checks if game has ended
			if(cpu_last_played[1] != 0):
				game_state = end_of_game(board)

			if not game_state:
				clear_screen()
				print_board(board)

				# Prints local last played piece and corresponding player
				if(local_last_played[1] != 0):
					print("Player {} dropped a piece into column {}".format(local_last_played[0], local_last_played[1]))

				# Prints CPU last played piece and corresponding player
				if(cpu_last_played[1] != 0):
					print("Player {} dropped a piece into column {}".format(cpu_last_played[0], cpu_last_played[1]))

				# Stores local last played piece and corresponding player and executes player turn
				if(1 + 2 * i <= n_players):
					local_last_played[0] = 1 + 2 * i
					local_last_played[1] = execute_player_turn(board, 1 + 2 * i)

				game_state = end_of_game(board)
			# If game has ended, prints the board and the winner
			if(game_state):
				game_end = 1
				clear_screen()
				print_board(board)
				print("Player {} wins!".format(game_state) if game_state != 3 else "Draw!")
				break
			elif(2 + 2 * i <= n_players):
				# Stores CPU last played piece and corresponding player and executes player turn
				cpu_last_played[0] = 2 + 2 * i
				cpu_last_played[1] = cpu_player_selector(cpu_player, board, 2 + 2 * i)


if __name__ == "__main__":
	main()